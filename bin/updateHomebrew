#!/usr/bin/env bash

_mainScript_() {

  [[ "$OSTYPE" != "darwin"* ]] \
    && fatal "We are not on macOS" "$LINENO"

  if ! command -v brew &>/dev/null; then fatal "Can not continue wthout homebrew" "${LINENO}"; fi

  notice "Updating Homebrew..."
  _execute_ -vp "brew update"
  _execute_ -vp "brew upgrade"

  _upgradeCasks_() {
    notice "Updating casks ..."
    local c cask

    # Sometimes license files can get old and cause 'brew cask' to throw errors.  This can help
    # identify the culprits
    # shellcheck disable=2046,2063
    while read -r cask; do
      info "Possible license error detected. If 'brew cask list' throws license errors attempt to reinstall '$cask'"
    done < <(grep -ilr --include \*.rb license $(brew --prefix)/Caskroom/*/.metadata | awk -F '/' '{print $5}' | sort -u)

    # Now we update casks
    while read -r c; do
      # version="$(brew info --cask "${c}" | awk '{print $2}')"
      # installed=$(find "/usr/local/Caskroom/${c}" -type d -maxdepth 1 -maxdepth 1 -name "${c}")
      # if [[ "${version}" == "latest" ]]; then
      #   # info "Cask '$c' does not report version numbers. Update individually."
      #   continue
      # fi
      notice "'${c}' requires update."
      # verbose "From: ${installed}"
      # verbose "To: ${version}"
      _execute_ -vp "brew uninstall \"${c}\" --cask --force" "Uninstalled '${c}'"
      _execute_ -vp "brew install \"${c}\" --cask --force" "Reinstalled '${c}'"
    done < <(brew outdated --cask --greedy --verbose | awk '$4 != "latest" {print $1}')
  }
  _upgradeCasks_

  _upgradeAppStore_() {
    notice "Updating from Mac App Store via mas..."
    _execute_ -vp "mas upgrade"
  }
  _upgradeAppStore_

  notice "Cleaning Up..."
  _execute_ -vp "brew cleanup"

} # end _mainScript_

_sourceHelperFiles_() {
  local filesToSource
  local sourceFile

  filesToSource=(
    "${HOME}/dotfiles/scripting/helpers/baseHelpers.bash"
  )
  for sourceFile in "${filesToSource[@]}"; do
    [ ! -f "$sourceFile" ] \
      && {
        echo "error: Can not find sourcefile '$sourceFile'. Exiting."
        exit 1
      }
    source "$sourceFile"
  done
}
_sourceHelperFiles_

# Set Flags
quiet=false
printLog=false
logErrors=true
verbose=false
force=false
dryrun=false
declare -a args=()

# Options and Usage
# -----------------------------------
_usage_() {
  cat <<EOF

  $(basename "$0") [OPTION]...

  This script upgrades Mac OS applications managed by Homewbrew, Homebrew Cask, and Mas.

 ${bold}Option Flags:${reset}

  -h, --help        Display this help and exit
  -l, --log         Print log to file
  -L, --noErrorLog  Default behavior is to print log level error and fatal to a log. Use
                    this flag to generate no log files at all.
  -n, --dryrun      Non-destructive. Makes no permanent changes.
  -q, --quiet       Quiet (no output)
  -v, --verbose     Output more information. (Items echoed to 'verbose')
EOF
}

_parseOptions_() {
  # Iterate over options
  # breaking -ab into -a -b when needed and --foo=bar into --foo bar
  optstring=h
  unset options
  while (($#)); do
    case $1 in
      # If option is of type -ab
      -[!-]?*)
        # Loop over each character starting with the second
        for ((i = 1; i < ${#1}; i++)); do
          c=${1:i:1}
          options+=("-$c") # Add current char to options
          # If option takes a required argument, and it's not the last char make
          # the rest of the string its argument
          if [[ $optstring == *"$c:"* && ${1:i+1} ]]; then
            options+=("${1:i+1}")
            break
          fi
        done
        ;;
      # If option is of type --foo=bar
      --?*=*) options+=("${1%%=*}" "${1#*=}") ;;
      # add --endopts for --
      --) options+=(--endopts) ;;
      # Otherwise, nothing special
      *) options+=("$1") ;;
    esac
    shift
  done
  set -- "${options[@]}"
  unset options

  # Read the options and set stuff
  while [[ $1 == -?* ]]; do
    case $1 in
      -h | --help)
        _usage_ >&2
        _safeExit_
        ;;
      -L | --noErrorLog) logErrors=false ;;
      -n | --dryrun) dryrun=true ;;
      -v | --verbose) verbose=true ;;
      -l | --log) printLog=true ;;
      -q | --quiet) quiet=true ;;
      --endopts)
        shift
        break
        ;;
      *) die "invalid option: '$1'." ;;
    esac
    shift
  done
  args+=("$@") # Store the remaining user input as arguments.
}
_parseOptions_ "$@"

# Initialize and run the script
trap '_trapCleanup_ $LINENO $BASH_LINENO "$BASH_COMMAND" "${FUNCNAME[*]}" "$0" "${BASH_SOURCE[0]}"' \
  EXIT INT TERM SIGINT SIGQUIT
set -o errtrace                           # Trap errors in subshells and functions
set -o errexit                            # Exit on error. Append '||true' if you expect an error
set -o pipefail                           # Use last non-zero exit code in a pipeline
shopt -s nullglob globstar                # Make `for f in *.txt` work when `*.txt` matches zero files
IFS=$' \n\t'                              # Set IFS to preferred implementation
# set -o xtrace                           # Uncomment to run in debug mode
set -o nounset                            # Disallow expansion of unset variables
# [[ $# -eq 0 ]] && _parseOptions_ "-h"   # Uncomment to force arguments when invoking the script
#_makeTempDir_ "$(basename "$0")"         # Uncomment to create a temp directory '$tmpDir'
_acquireScriptLock_                       # Uncomment to acquire script lock
_mainScript_                              # Run script
_safeExit_                                # Exit cleanly
